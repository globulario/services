package keepalived

import (
	"bytes"
	"fmt"
	"sort"
	"strings"
	"text/template"

	"github.com/globulario/services/golang/nodeagent/nodeagent_server/internal/ingress"
)

// RenderInput contains the parameters for rendering keepalived configuration
type RenderInput struct {
	NodeID   string
	Priority int
	Spec     ingress.VIPFailoverSpec
}

// keepalivedConfigTemplate is the template for keepalived.conf
const keepalivedConfigTemplate = `# keepalived configuration generated by Globular node-agent
# Node: {{.NodeID}}
# Priority: {{.Priority}}

{{- if .HealthScript}}

vrrp_script chk_ingress {
  script "{{.HealthScriptPath}}"
  interval 2
  fall 2
  rise 2
}
{{- end}}

vrrp_instance VI_{{.VirtualRouterID}} {
  state BACKUP
  interface {{.Interface}}
  virtual_router_id {{.VirtualRouterID}}
  priority {{.Priority}}
  advert_int {{.AdvertInterval}}
  {{- if not .Preempt}}
  nopreempt
  {{- end}}
  {{- if .AuthPass}}
  authentication {
    auth_type PASS
    auth_pass {{.AuthPass}}
  }
  {{- end}}
  virtual_ipaddress {
    {{.VIP}}
  }
  {{- if .HealthScript}}
  track_script {
    chk_ingress
  }
  {{- end}}
}
`

// templateData contains the data for rendering the keepalived config template
type templateData struct {
	NodeID           string
	Priority         int
	Interface        string
	VirtualRouterID  int
	VIP              string
	AdvertInterval   int
	Preempt          bool
	AuthPass         string
	HealthScript     bool
	HealthScriptPath string
}

// RenderConfig renders the keepalived.conf configuration file
func RenderConfig(in RenderInput) (string, error) {
	// Ensure VIP has CIDR notation (add /32 if missing)
	vip := in.Spec.VIP
	if !strings.Contains(vip, "/") {
		// Determine if IPv4 or IPv6
		if strings.Contains(vip, ":") {
			vip = vip + "/128" // IPv6
		} else {
			vip = vip + "/32" // IPv4
		}
	}

	// Calculate advertisement interval in seconds (convert from ms)
	advertInterval := in.Spec.AdvertIntervalMs / 1000
	if advertInterval < 1 {
		advertInterval = 1 // Default to 1 second
	}

	data := templateData{
		NodeID:           in.NodeID,
		Priority:         in.Priority,
		Interface:        in.Spec.Interface,
		VirtualRouterID:  in.Spec.VirtualRouterID,
		VIP:              vip,
		AdvertInterval:   advertInterval,
		Preempt:          in.Spec.Preempt,
		AuthPass:         in.Spec.AuthPass,
		HealthScript:     len(in.Spec.CheckTCPPorts) > 0,
		HealthScriptPath: "/usr/lib/globular/bin/check-ingress.sh",
	}

	tmpl, err := template.New("keepalived.conf").Parse(keepalivedConfigTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}

	return buf.String(), nil
}

// healthScriptTemplate is the template for the TCP port health check script
const healthScriptTemplate = `#!/bin/bash
# Health check script for keepalived
# Generated by Globular node-agent

set -e

{{range .Ports}}# Check port {{.}}
if ! ss -lnt | grep -q ':{{.}} '; then
  if ! nc -z 127.0.0.1 {{.}} 2>/dev/null; then
    echo "Port {{.}} not listening" >&2
    exit 1
  fi
fi

{{end}}# All checks passed
exit 0
`

// healthScriptData contains the data for rendering the health script template
type healthScriptData struct {
	Ports []int
}

// RenderHealthScriptTCP renders a bash health check script for TCP port checks
func RenderHealthScriptTCP(ports []int) (string, error) {
	if len(ports) == 0 {
		return "", fmt.Errorf("no ports specified for health check")
	}

	// Sort ports for deterministic output
	sortedPorts := make([]int, len(ports))
	copy(sortedPorts, ports)
	sort.Ints(sortedPorts)

	data := healthScriptData{
		Ports: sortedPorts,
	}

	tmpl, err := template.New("check-ingress.sh").Parse(healthScriptTemplate)
	if err != nil {
		return "", fmt.Errorf("parse template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return "", fmt.Errorf("execute template: %w", err)
	}

	return buf.String(), nil
}
