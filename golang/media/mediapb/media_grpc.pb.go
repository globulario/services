// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: media.proto

package mediapb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MediaService_Stop_FullMethodName                           = "/media.MediaService/Stop"
	MediaService_UploadVideo_FullMethodName                    = "/media.MediaService/UploadVideo"
	MediaService_CreateVideoPreview_FullMethodName             = "/media.MediaService/CreateVideoPreview"
	MediaService_CreateVideoTimeLine_FullMethodName            = "/media.MediaService/CreateVideoTimeLine"
	MediaService_ConvertVideoToMpeg4H264_FullMethodName        = "/media.MediaService/ConvertVideoToMpeg4H264"
	MediaService_ConvertVideoToHls_FullMethodName              = "/media.MediaService/ConvertVideoToHls"
	MediaService_StartProcessVideo_FullMethodName              = "/media.MediaService/StartProcessVideo"
	MediaService_StartProcessAudio_FullMethodName              = "/media.MediaService/StartProcessAudio"
	MediaService_StopProcessVideo_FullMethodName               = "/media.MediaService/StopProcessVideo"
	MediaService_IsProcessVideo_FullMethodName                 = "/media.MediaService/IsProcessVideo"
	MediaService_SetVideoConversion_FullMethodName             = "/media.MediaService/SetVideoConversion"
	MediaService_SetVideoStreamConversion_FullMethodName       = "/media.MediaService/SetVideoStreamConversion"
	MediaService_SetStartVideoConversionHour_FullMethodName    = "/media.MediaService/SetStartVideoConversionHour"
	MediaService_SetMaximumVideoConversionDelay_FullMethodName = "/media.MediaService/SetMaximumVideoConversionDelay"
	MediaService_GetVideoConversionErrors_FullMethodName       = "/media.MediaService/GetVideoConversionErrors"
	MediaService_ClearVideoConversionErrors_FullMethodName     = "/media.MediaService/ClearVideoConversionErrors"
	MediaService_ClearVideoConversionError_FullMethodName      = "/media.MediaService/ClearVideoConversionError"
	MediaService_ClearVideoConversionLogs_FullMethodName       = "/media.MediaService/ClearVideoConversionLogs"
	MediaService_GetVideoConversionLogs_FullMethodName         = "/media.MediaService/GetVideoConversionLogs"
	MediaService_GeneratePlaylist_FullMethodName               = "/media.MediaService/GeneratePlaylist"
	MediaService_CreateVttFile_FullMethodName                  = "/media.MediaService/CreateVttFile"
)

// MediaServiceClient is the client API for MediaService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Media service definition.
type MediaServiceClient interface {
	// Stop the server.
	// This RPC allows the client to request the server to stop.
	Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// Upload a video from a URL (e.g., YouTube, Hulu, Pornhub).
	UploadVideo(ctx context.Context, in *UploadVideoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[UploadVideoResponse], error)
	// Create a video preview.
	CreateVideoPreview(ctx context.Context, in *CreateVideoPreviewRequest, opts ...grpc.CallOption) (*CreateVideoPreviewResponse, error)
	// Create a video timeline.
	CreateVideoTimeLine(ctx context.Context, in *CreateVideoTimeLineRequest, opts ...grpc.CallOption) (*CreateVideoTimeLineResponse, error)
	// Convert a video file to MPEG-4 AVC (H.264) format.
	ConvertVideoToMpeg4H264(ctx context.Context, in *ConvertVideoToMpeg4H264Request, opts ...grpc.CallOption) (*ConvertVideoToMpeg4H264Response, error)
	// Convert a video file to HLS (HTTP Live Streaming) format.
	ConvertVideoToHls(ctx context.Context, in *ConvertVideoToHlsRequest, opts ...grpc.CallOption) (*ConvertVideoToHlsResponse, error)
	// Start processing video on the server.
	StartProcessVideo(ctx context.Context, in *StartProcessVideoRequest, opts ...grpc.CallOption) (*StartProcessVideoResponse, error)
	// Start processing audio on the server.
	StartProcessAudio(ctx context.Context, in *StartProcessAudioRequest, opts ...grpc.CallOption) (*StartProcessAudioResponse, error)
	// Stop processing video on the server.
	StopProcessVideo(ctx context.Context, in *StopProcessVideoRequest, opts ...grpc.CallOption) (*StopProcessVideoResponse, error)
	// Check if video processing is currently running.
	IsProcessVideo(ctx context.Context, in *IsProcessVideoRequest, opts ...grpc.CallOption) (*IsProcessVideoResponse, error)
	// Set video processing configuration.
	SetVideoConversion(ctx context.Context, in *SetVideoConversionRequest, opts ...grpc.CallOption) (*SetVideoConversionResponse, error)
	// Set video stream conversion configuration.
	SetVideoStreamConversion(ctx context.Context, in *SetVideoStreamConversionRequest, opts ...grpc.CallOption) (*SetVideoStreamConversionResponse, error)
	// Set the start hour for video conversion.
	SetStartVideoConversionHour(ctx context.Context, in *SetStartVideoConversionHourRequest, opts ...grpc.CallOption) (*SetStartVideoConversionHourResponse, error)
	// Set the maximum delay for video conversion.
	SetMaximumVideoConversionDelay(ctx context.Context, in *SetMaximumVideoConversionDelayRequest, opts ...grpc.CallOption) (*SetMaximumVideoConversionDelayResponse, error)
	// Retrieve the list of failed video conversions.
	GetVideoConversionErrors(ctx context.Context, in *GetVideoConversionErrorsRequest, opts ...grpc.CallOption) (*GetVideoConversionErrorsResponse, error)
	// Clear all video conversion errors.
	ClearVideoConversionErrors(ctx context.Context, in *ClearVideoConversionErrorsRequest, opts ...grpc.CallOption) (*ClearVideoConversionErrorsResponse, error)
	// Clear a specific video conversion error.
	ClearVideoConversionError(ctx context.Context, in *ClearVideoConversionErrorRequest, opts ...grpc.CallOption) (*ClearVideoConversionErrorResponse, error)
	// Clear video conversion logs.
	ClearVideoConversionLogs(ctx context.Context, in *ClearVideoConversionLogsRequest, opts ...grpc.CallOption) (*ClearVideoConversionLogsResponse, error)
	// Retrieve video conversion logs.
	GetVideoConversionLogs(ctx context.Context, in *GetVideoConversionLogsRequest, opts ...grpc.CallOption) (*GetVideoConversionLogsResponse, error)
	// Generate playlists for a directory.
	GeneratePlaylist(ctx context.Context, in *GeneratePlaylistRequest, opts ...grpc.CallOption) (*GeneratePlaylistResponse, error)
	// Create a VTT file for a video.
	CreateVttFile(ctx context.Context, in *CreateVttFileRequest, opts ...grpc.CallOption) (*CreateVttFileResponse, error)
}

type mediaServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMediaServiceClient(cc grpc.ClientConnInterface) MediaServiceClient {
	return &mediaServiceClient{cc}
}

func (c *mediaServiceClient) Stop(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopResponse)
	err := c.cc.Invoke(ctx, MediaService_Stop_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) UploadVideo(ctx context.Context, in *UploadVideoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[UploadVideoResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MediaService_ServiceDesc.Streams[0], MediaService_UploadVideo_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[UploadVideoRequest, UploadVideoResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MediaService_UploadVideoClient = grpc.ServerStreamingClient[UploadVideoResponse]

func (c *mediaServiceClient) CreateVideoPreview(ctx context.Context, in *CreateVideoPreviewRequest, opts ...grpc.CallOption) (*CreateVideoPreviewResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVideoPreviewResponse)
	err := c.cc.Invoke(ctx, MediaService_CreateVideoPreview_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) CreateVideoTimeLine(ctx context.Context, in *CreateVideoTimeLineRequest, opts ...grpc.CallOption) (*CreateVideoTimeLineResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVideoTimeLineResponse)
	err := c.cc.Invoke(ctx, MediaService_CreateVideoTimeLine_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) ConvertVideoToMpeg4H264(ctx context.Context, in *ConvertVideoToMpeg4H264Request, opts ...grpc.CallOption) (*ConvertVideoToMpeg4H264Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvertVideoToMpeg4H264Response)
	err := c.cc.Invoke(ctx, MediaService_ConvertVideoToMpeg4H264_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) ConvertVideoToHls(ctx context.Context, in *ConvertVideoToHlsRequest, opts ...grpc.CallOption) (*ConvertVideoToHlsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConvertVideoToHlsResponse)
	err := c.cc.Invoke(ctx, MediaService_ConvertVideoToHls_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) StartProcessVideo(ctx context.Context, in *StartProcessVideoRequest, opts ...grpc.CallOption) (*StartProcessVideoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartProcessVideoResponse)
	err := c.cc.Invoke(ctx, MediaService_StartProcessVideo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) StartProcessAudio(ctx context.Context, in *StartProcessAudioRequest, opts ...grpc.CallOption) (*StartProcessAudioResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StartProcessAudioResponse)
	err := c.cc.Invoke(ctx, MediaService_StartProcessAudio_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) StopProcessVideo(ctx context.Context, in *StopProcessVideoRequest, opts ...grpc.CallOption) (*StopProcessVideoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StopProcessVideoResponse)
	err := c.cc.Invoke(ctx, MediaService_StopProcessVideo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) IsProcessVideo(ctx context.Context, in *IsProcessVideoRequest, opts ...grpc.CallOption) (*IsProcessVideoResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsProcessVideoResponse)
	err := c.cc.Invoke(ctx, MediaService_IsProcessVideo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) SetVideoConversion(ctx context.Context, in *SetVideoConversionRequest, opts ...grpc.CallOption) (*SetVideoConversionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetVideoConversionResponse)
	err := c.cc.Invoke(ctx, MediaService_SetVideoConversion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) SetVideoStreamConversion(ctx context.Context, in *SetVideoStreamConversionRequest, opts ...grpc.CallOption) (*SetVideoStreamConversionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetVideoStreamConversionResponse)
	err := c.cc.Invoke(ctx, MediaService_SetVideoStreamConversion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) SetStartVideoConversionHour(ctx context.Context, in *SetStartVideoConversionHourRequest, opts ...grpc.CallOption) (*SetStartVideoConversionHourResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetStartVideoConversionHourResponse)
	err := c.cc.Invoke(ctx, MediaService_SetStartVideoConversionHour_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) SetMaximumVideoConversionDelay(ctx context.Context, in *SetMaximumVideoConversionDelayRequest, opts ...grpc.CallOption) (*SetMaximumVideoConversionDelayResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetMaximumVideoConversionDelayResponse)
	err := c.cc.Invoke(ctx, MediaService_SetMaximumVideoConversionDelay_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) GetVideoConversionErrors(ctx context.Context, in *GetVideoConversionErrorsRequest, opts ...grpc.CallOption) (*GetVideoConversionErrorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVideoConversionErrorsResponse)
	err := c.cc.Invoke(ctx, MediaService_GetVideoConversionErrors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) ClearVideoConversionErrors(ctx context.Context, in *ClearVideoConversionErrorsRequest, opts ...grpc.CallOption) (*ClearVideoConversionErrorsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearVideoConversionErrorsResponse)
	err := c.cc.Invoke(ctx, MediaService_ClearVideoConversionErrors_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) ClearVideoConversionError(ctx context.Context, in *ClearVideoConversionErrorRequest, opts ...grpc.CallOption) (*ClearVideoConversionErrorResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearVideoConversionErrorResponse)
	err := c.cc.Invoke(ctx, MediaService_ClearVideoConversionError_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) ClearVideoConversionLogs(ctx context.Context, in *ClearVideoConversionLogsRequest, opts ...grpc.CallOption) (*ClearVideoConversionLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ClearVideoConversionLogsResponse)
	err := c.cc.Invoke(ctx, MediaService_ClearVideoConversionLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) GetVideoConversionLogs(ctx context.Context, in *GetVideoConversionLogsRequest, opts ...grpc.CallOption) (*GetVideoConversionLogsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVideoConversionLogsResponse)
	err := c.cc.Invoke(ctx, MediaService_GetVideoConversionLogs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) GeneratePlaylist(ctx context.Context, in *GeneratePlaylistRequest, opts ...grpc.CallOption) (*GeneratePlaylistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GeneratePlaylistResponse)
	err := c.cc.Invoke(ctx, MediaService_GeneratePlaylist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaServiceClient) CreateVttFile(ctx context.Context, in *CreateVttFileRequest, opts ...grpc.CallOption) (*CreateVttFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVttFileResponse)
	err := c.cc.Invoke(ctx, MediaService_CreateVttFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MediaServiceServer is the server API for MediaService service.
// All implementations should embed UnimplementedMediaServiceServer
// for forward compatibility.
//
// Media service definition.
type MediaServiceServer interface {
	// Stop the server.
	// This RPC allows the client to request the server to stop.
	Stop(context.Context, *StopRequest) (*StopResponse, error)
	// Upload a video from a URL (e.g., YouTube, Hulu, Pornhub).
	UploadVideo(*UploadVideoRequest, grpc.ServerStreamingServer[UploadVideoResponse]) error
	// Create a video preview.
	CreateVideoPreview(context.Context, *CreateVideoPreviewRequest) (*CreateVideoPreviewResponse, error)
	// Create a video timeline.
	CreateVideoTimeLine(context.Context, *CreateVideoTimeLineRequest) (*CreateVideoTimeLineResponse, error)
	// Convert a video file to MPEG-4 AVC (H.264) format.
	ConvertVideoToMpeg4H264(context.Context, *ConvertVideoToMpeg4H264Request) (*ConvertVideoToMpeg4H264Response, error)
	// Convert a video file to HLS (HTTP Live Streaming) format.
	ConvertVideoToHls(context.Context, *ConvertVideoToHlsRequest) (*ConvertVideoToHlsResponse, error)
	// Start processing video on the server.
	StartProcessVideo(context.Context, *StartProcessVideoRequest) (*StartProcessVideoResponse, error)
	// Start processing audio on the server.
	StartProcessAudio(context.Context, *StartProcessAudioRequest) (*StartProcessAudioResponse, error)
	// Stop processing video on the server.
	StopProcessVideo(context.Context, *StopProcessVideoRequest) (*StopProcessVideoResponse, error)
	// Check if video processing is currently running.
	IsProcessVideo(context.Context, *IsProcessVideoRequest) (*IsProcessVideoResponse, error)
	// Set video processing configuration.
	SetVideoConversion(context.Context, *SetVideoConversionRequest) (*SetVideoConversionResponse, error)
	// Set video stream conversion configuration.
	SetVideoStreamConversion(context.Context, *SetVideoStreamConversionRequest) (*SetVideoStreamConversionResponse, error)
	// Set the start hour for video conversion.
	SetStartVideoConversionHour(context.Context, *SetStartVideoConversionHourRequest) (*SetStartVideoConversionHourResponse, error)
	// Set the maximum delay for video conversion.
	SetMaximumVideoConversionDelay(context.Context, *SetMaximumVideoConversionDelayRequest) (*SetMaximumVideoConversionDelayResponse, error)
	// Retrieve the list of failed video conversions.
	GetVideoConversionErrors(context.Context, *GetVideoConversionErrorsRequest) (*GetVideoConversionErrorsResponse, error)
	// Clear all video conversion errors.
	ClearVideoConversionErrors(context.Context, *ClearVideoConversionErrorsRequest) (*ClearVideoConversionErrorsResponse, error)
	// Clear a specific video conversion error.
	ClearVideoConversionError(context.Context, *ClearVideoConversionErrorRequest) (*ClearVideoConversionErrorResponse, error)
	// Clear video conversion logs.
	ClearVideoConversionLogs(context.Context, *ClearVideoConversionLogsRequest) (*ClearVideoConversionLogsResponse, error)
	// Retrieve video conversion logs.
	GetVideoConversionLogs(context.Context, *GetVideoConversionLogsRequest) (*GetVideoConversionLogsResponse, error)
	// Generate playlists for a directory.
	GeneratePlaylist(context.Context, *GeneratePlaylistRequest) (*GeneratePlaylistResponse, error)
	// Create a VTT file for a video.
	CreateVttFile(context.Context, *CreateVttFileRequest) (*CreateVttFileResponse, error)
}

// UnimplementedMediaServiceServer should be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMediaServiceServer struct{}

func (UnimplementedMediaServiceServer) Stop(context.Context, *StopRequest) (*StopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedMediaServiceServer) UploadVideo(*UploadVideoRequest, grpc.ServerStreamingServer[UploadVideoResponse]) error {
	return status.Errorf(codes.Unimplemented, "method UploadVideo not implemented")
}
func (UnimplementedMediaServiceServer) CreateVideoPreview(context.Context, *CreateVideoPreviewRequest) (*CreateVideoPreviewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVideoPreview not implemented")
}
func (UnimplementedMediaServiceServer) CreateVideoTimeLine(context.Context, *CreateVideoTimeLineRequest) (*CreateVideoTimeLineResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVideoTimeLine not implemented")
}
func (UnimplementedMediaServiceServer) ConvertVideoToMpeg4H264(context.Context, *ConvertVideoToMpeg4H264Request) (*ConvertVideoToMpeg4H264Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertVideoToMpeg4H264 not implemented")
}
func (UnimplementedMediaServiceServer) ConvertVideoToHls(context.Context, *ConvertVideoToHlsRequest) (*ConvertVideoToHlsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConvertVideoToHls not implemented")
}
func (UnimplementedMediaServiceServer) StartProcessVideo(context.Context, *StartProcessVideoRequest) (*StartProcessVideoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProcessVideo not implemented")
}
func (UnimplementedMediaServiceServer) StartProcessAudio(context.Context, *StartProcessAudioRequest) (*StartProcessAudioResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartProcessAudio not implemented")
}
func (UnimplementedMediaServiceServer) StopProcessVideo(context.Context, *StopProcessVideoRequest) (*StopProcessVideoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopProcessVideo not implemented")
}
func (UnimplementedMediaServiceServer) IsProcessVideo(context.Context, *IsProcessVideoRequest) (*IsProcessVideoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsProcessVideo not implemented")
}
func (UnimplementedMediaServiceServer) SetVideoConversion(context.Context, *SetVideoConversionRequest) (*SetVideoConversionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVideoConversion not implemented")
}
func (UnimplementedMediaServiceServer) SetVideoStreamConversion(context.Context, *SetVideoStreamConversionRequest) (*SetVideoStreamConversionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetVideoStreamConversion not implemented")
}
func (UnimplementedMediaServiceServer) SetStartVideoConversionHour(context.Context, *SetStartVideoConversionHourRequest) (*SetStartVideoConversionHourResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetStartVideoConversionHour not implemented")
}
func (UnimplementedMediaServiceServer) SetMaximumVideoConversionDelay(context.Context, *SetMaximumVideoConversionDelayRequest) (*SetMaximumVideoConversionDelayResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMaximumVideoConversionDelay not implemented")
}
func (UnimplementedMediaServiceServer) GetVideoConversionErrors(context.Context, *GetVideoConversionErrorsRequest) (*GetVideoConversionErrorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVideoConversionErrors not implemented")
}
func (UnimplementedMediaServiceServer) ClearVideoConversionErrors(context.Context, *ClearVideoConversionErrorsRequest) (*ClearVideoConversionErrorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearVideoConversionErrors not implemented")
}
func (UnimplementedMediaServiceServer) ClearVideoConversionError(context.Context, *ClearVideoConversionErrorRequest) (*ClearVideoConversionErrorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearVideoConversionError not implemented")
}
func (UnimplementedMediaServiceServer) ClearVideoConversionLogs(context.Context, *ClearVideoConversionLogsRequest) (*ClearVideoConversionLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearVideoConversionLogs not implemented")
}
func (UnimplementedMediaServiceServer) GetVideoConversionLogs(context.Context, *GetVideoConversionLogsRequest) (*GetVideoConversionLogsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVideoConversionLogs not implemented")
}
func (UnimplementedMediaServiceServer) GeneratePlaylist(context.Context, *GeneratePlaylistRequest) (*GeneratePlaylistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GeneratePlaylist not implemented")
}
func (UnimplementedMediaServiceServer) CreateVttFile(context.Context, *CreateVttFileRequest) (*CreateVttFileResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVttFile not implemented")
}
func (UnimplementedMediaServiceServer) testEmbeddedByValue() {}

// UnsafeMediaServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MediaServiceServer will
// result in compilation errors.
type UnsafeMediaServiceServer interface {
	mustEmbedUnimplementedMediaServiceServer()
}

func RegisterMediaServiceServer(s grpc.ServiceRegistrar, srv MediaServiceServer) {
	// If the following call pancis, it indicates UnimplementedMediaServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MediaService_ServiceDesc, srv)
}

func _MediaService_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).Stop(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_UploadVideo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(UploadVideoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(MediaServiceServer).UploadVideo(m, &grpc.GenericServerStream[UploadVideoRequest, UploadVideoResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MediaService_UploadVideoServer = grpc.ServerStreamingServer[UploadVideoResponse]

func _MediaService_CreateVideoPreview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVideoPreviewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).CreateVideoPreview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_CreateVideoPreview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).CreateVideoPreview(ctx, req.(*CreateVideoPreviewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_CreateVideoTimeLine_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVideoTimeLineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).CreateVideoTimeLine(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_CreateVideoTimeLine_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).CreateVideoTimeLine(ctx, req.(*CreateVideoTimeLineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_ConvertVideoToMpeg4H264_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertVideoToMpeg4H264Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).ConvertVideoToMpeg4H264(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_ConvertVideoToMpeg4H264_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).ConvertVideoToMpeg4H264(ctx, req.(*ConvertVideoToMpeg4H264Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_ConvertVideoToHls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConvertVideoToHlsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).ConvertVideoToHls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_ConvertVideoToHls_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).ConvertVideoToHls(ctx, req.(*ConvertVideoToHlsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_StartProcessVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProcessVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).StartProcessVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_StartProcessVideo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).StartProcessVideo(ctx, req.(*StartProcessVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_StartProcessAudio_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartProcessAudioRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).StartProcessAudio(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_StartProcessAudio_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).StartProcessAudio(ctx, req.(*StartProcessAudioRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_StopProcessVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopProcessVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).StopProcessVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_StopProcessVideo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).StopProcessVideo(ctx, req.(*StopProcessVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_IsProcessVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsProcessVideoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).IsProcessVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_IsProcessVideo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).IsProcessVideo(ctx, req.(*IsProcessVideoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_SetVideoConversion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVideoConversionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).SetVideoConversion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_SetVideoConversion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).SetVideoConversion(ctx, req.(*SetVideoConversionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_SetVideoStreamConversion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetVideoStreamConversionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).SetVideoStreamConversion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_SetVideoStreamConversion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).SetVideoStreamConversion(ctx, req.(*SetVideoStreamConversionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_SetStartVideoConversionHour_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetStartVideoConversionHourRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).SetStartVideoConversionHour(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_SetStartVideoConversionHour_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).SetStartVideoConversionHour(ctx, req.(*SetStartVideoConversionHourRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_SetMaximumVideoConversionDelay_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMaximumVideoConversionDelayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).SetMaximumVideoConversionDelay(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_SetMaximumVideoConversionDelay_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).SetMaximumVideoConversionDelay(ctx, req.(*SetMaximumVideoConversionDelayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_GetVideoConversionErrors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoConversionErrorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).GetVideoConversionErrors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_GetVideoConversionErrors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).GetVideoConversionErrors(ctx, req.(*GetVideoConversionErrorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_ClearVideoConversionErrors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearVideoConversionErrorsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).ClearVideoConversionErrors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_ClearVideoConversionErrors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).ClearVideoConversionErrors(ctx, req.(*ClearVideoConversionErrorsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_ClearVideoConversionError_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearVideoConversionErrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).ClearVideoConversionError(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_ClearVideoConversionError_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).ClearVideoConversionError(ctx, req.(*ClearVideoConversionErrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_ClearVideoConversionLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearVideoConversionLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).ClearVideoConversionLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_ClearVideoConversionLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).ClearVideoConversionLogs(ctx, req.(*ClearVideoConversionLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_GetVideoConversionLogs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVideoConversionLogsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).GetVideoConversionLogs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_GetVideoConversionLogs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).GetVideoConversionLogs(ctx, req.(*GetVideoConversionLogsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_GeneratePlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GeneratePlaylistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).GeneratePlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_GeneratePlaylist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).GeneratePlaylist(ctx, req.(*GeneratePlaylistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaService_CreateVttFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVttFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaServiceServer).CreateVttFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MediaService_CreateVttFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaServiceServer).CreateVttFile(ctx, req.(*CreateVttFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MediaService_ServiceDesc is the grpc.ServiceDesc for MediaService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MediaService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "media.MediaService",
	HandlerType: (*MediaServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Stop",
			Handler:    _MediaService_Stop_Handler,
		},
		{
			MethodName: "CreateVideoPreview",
			Handler:    _MediaService_CreateVideoPreview_Handler,
		},
		{
			MethodName: "CreateVideoTimeLine",
			Handler:    _MediaService_CreateVideoTimeLine_Handler,
		},
		{
			MethodName: "ConvertVideoToMpeg4H264",
			Handler:    _MediaService_ConvertVideoToMpeg4H264_Handler,
		},
		{
			MethodName: "ConvertVideoToHls",
			Handler:    _MediaService_ConvertVideoToHls_Handler,
		},
		{
			MethodName: "StartProcessVideo",
			Handler:    _MediaService_StartProcessVideo_Handler,
		},
		{
			MethodName: "StartProcessAudio",
			Handler:    _MediaService_StartProcessAudio_Handler,
		},
		{
			MethodName: "StopProcessVideo",
			Handler:    _MediaService_StopProcessVideo_Handler,
		},
		{
			MethodName: "IsProcessVideo",
			Handler:    _MediaService_IsProcessVideo_Handler,
		},
		{
			MethodName: "SetVideoConversion",
			Handler:    _MediaService_SetVideoConversion_Handler,
		},
		{
			MethodName: "SetVideoStreamConversion",
			Handler:    _MediaService_SetVideoStreamConversion_Handler,
		},
		{
			MethodName: "SetStartVideoConversionHour",
			Handler:    _MediaService_SetStartVideoConversionHour_Handler,
		},
		{
			MethodName: "SetMaximumVideoConversionDelay",
			Handler:    _MediaService_SetMaximumVideoConversionDelay_Handler,
		},
		{
			MethodName: "GetVideoConversionErrors",
			Handler:    _MediaService_GetVideoConversionErrors_Handler,
		},
		{
			MethodName: "ClearVideoConversionErrors",
			Handler:    _MediaService_ClearVideoConversionErrors_Handler,
		},
		{
			MethodName: "ClearVideoConversionError",
			Handler:    _MediaService_ClearVideoConversionError_Handler,
		},
		{
			MethodName: "ClearVideoConversionLogs",
			Handler:    _MediaService_ClearVideoConversionLogs_Handler,
		},
		{
			MethodName: "GetVideoConversionLogs",
			Handler:    _MediaService_GetVideoConversionLogs_Handler,
		},
		{
			MethodName: "GeneratePlaylist",
			Handler:    _MediaService_GeneratePlaylist_Handler,
		},
		{
			MethodName: "CreateVttFile",
			Handler:    _MediaService_CreateVttFile_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadVideo",
			Handler:       _MediaService_UploadVideo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "media.proto",
}
